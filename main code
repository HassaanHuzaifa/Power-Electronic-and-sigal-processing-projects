import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Robot parameters
a1, a2 = 0.5, 0.5     # Link lengths (m)
m1, m2 = 10.0, 10.0     # Masses (kg)
I1, I2 = 0.1, 0.1     # Inertias (kg.m^2)
g = 9.81              # Gravity (m/s^2)

# Mobile base parameters
r = 0.05              # Wheel radius (m)
L = 0.3               # Distance between wheels (m)

# Controller gains
Kp = np.diag([100, 100])
Kd = np.diag([20, 20])

# Desired joint trajectory
def desired_theta(t):
    return np.array([np.pi/4 * np.sin(0.5*t), np.pi/6 * np.cos(0.5*t)])

def desired_dtheta(t):
    return np.array([np.pi/4 * 0.5 * np.cos(0.5*t), -np.pi/6 * 0.5 * np.sin(0.5*t)])

def desired_ddtheta(t):
    return np.array([-np.pi/4 * 0.25 * np.sin(0.5*t), -np.pi/6 * 0.25 * np.cos(0.5*t)])

# Inertia matrix
def M_matrix(theta):
    th1, th2 = theta
    m11 = I1 + I2 + m1*(a1/2)**2 + m2*(a1**2 + (a2**2)/4 + a1*a2*np.cos(th2))
    m12 = I2 + m2*((a2**2)/4 + a1*a2/2*np.cos(th2))
    m21 = m12
    m22 = I2 + m2*(a2**2)/4
    return np.array([[m11, m12], [m21, m22]])

# Coriolis matrix
def C_matrix(theta, dtheta):
    th1, th2 = theta
    dth1, dth2 = dtheta
    h = -m2*a1*a2/2*np.sin(th2)
    c11 = h*dth2
    c12 = h*(dth1 + dth2)
    c21 = -h*dth1
    c22 = 0
    return np.array([[c11, c12], [c21, c22]])

# Gravity vector
def G_vector(theta):
    th1, th2 = theta
    g1 = (m1*a1/2 + m2*a1)*g*np.cos(th1) + m2*a2/2*g*np.cos(th1 + th2)
    g2 = m2*a2/2*g*np.cos(th1 + th2)
    return np.array([g1, g2])

# Mobile base kinematics
def base_kinematics(v, w, theta_r):
    dx = v * np.cos(theta_r)
    dy = v * np.sin(theta_r)
    dtheta_r = w
    return np.array([dx, dy, dtheta_r])

# Integrated dynamics for base + manipulator
def full_system(t, state):
    # Extract states
    x, y, theta_r = state[0:3]
    theta = state[3:5]
    dtheta = state[5:7]

    # Mobile base control (simple path following)
    v_cmd = 0.5
    w_cmd = 0.1
    dpose = base_kinematics(v_cmd, w_cmd, theta_r)

    # Manipulator control
    theta_d = desired_theta(t)
    dtheta_d = desired_dtheta(t)
    ddtheta_d = desired_ddtheta(t)

    e = theta_d - theta
    de = dtheta_d - dtheta

    M = M_matrix(theta)
    C = C_matrix(theta, dtheta)
    G = G_vector(theta)

    tau = M @ (ddtheta_d + Kd @ de + Kp @ e) + C @ dtheta + G
    ddtheta = np.linalg.inv(M) @ (tau - C @ dtheta - G)

    return np.concatenate((dpose, dtheta, ddtheta))

# Initial state [x, y, theta_r, theta1, theta2, dtheta1, dtheta2]
y0_full = [0, 0, 0, 0, 0, 0, 0]
t_span_full = (0, 20)
t_eval_full = np.linspace(*t_span_full, 500)

# Simulate
sol_full = solve_ivp(full_system, t_span_full, y0_full, t_eval=t_eval_full)
sol_full.y.shape
